syntax = "proto3";

package world;

import "geometry.proto";
import "google/protobuf/struct.proto";
import "google/protobuf/timestamp.proto";
import "metrics.proto";

option go_package = "github.com/projectqai/proto/go";

// ---------------------------------------

message Entity {
  // metadata

  string id = 1;
  optional string label = 2;

  optional Controller controller = 3;
  optional Lifetime lifetime = 4;
  optional Priority priority = 5;
  optional Lease lease = 6;
  reserved 7;
  reserved 8;
  reserved 9;
  reserved 10;

  // cop

  optional GeoSpatialComponent geo = 11;
  optional SymbolComponent symbol = 12;
  optional CameraComponent camera = 15;
  optional DetectionComponent detection = 16;
  optional BearingComponent bearing = 17;
  reserved 20; // was LocationUncertaintyComponent
  optional TrackComponent track = 21;
  optional LocatorComponent locator = 22;
  optional KinematicsComponent kinematics = 24;
  optional GeoShapeComponent shape = 25;
  optional ClassificationComponent classification = 26;
  optional TransponderComponent transponder = 27;
  optional AdministrativeComponent administrative = 28;
  optional OrientationComponent orientation = 30;
  optional NavigationComponent navigation = 34;
  optional PowerComponent power = 33;
  optional CaptureComponent capture = 35;

  // experimental, dont use yet externally
  optional TaskableComponent taskable = 23;
  optional DeviceComponent device = 50;
  optional ConfigurationComponent config = 51;
  optional ConfigurableComponent configurable = 52;
  optional MissionComponent mission = 31;
  optional LinkComponent link = 32;
  optional MetricComponent metric = 36;
  optional SensorComponent sensor = 37;
  optional LocalShapeComponent local_shape = 29;

  optional InteractivityComponent interactivity = 60;
}

// A controller owns an entity.
// The engine normally rejects changes to the entity from non owners,
// but some future work might ask the controller to merge the change.
// in that case it MUST NOT be sent via push since push is eventually consistent
message Controller {
  optional string id = 1;
  optional string node = 2;
}

// Leases are used by controllers to negotiate exclusivity on an entity
// The engine rejects pushes that attempt to change the holder of an active lease,
// which a controller can use to "lock" something.
// Note that this is a local lock, it is not distirbuted vertically
message Lease {
  string controller = 1;
  optional google.protobuf.Timestamp expires = 2;
}

message Lifetime {
  // time this entity should become valid.
  // will be set to now automatically if omited
  optional google.protobuf.Timestamp from = 1;

  // entities with until after or at now are considered expired / deleted
  optional google.protobuf.Timestamp until = 2;

  // last time we have seen this entity, normally between from and until
  // if set, updates to an entity with older fresh value are ignored by default
  optional google.protobuf.Timestamp fresh = 3;
}

enum Priority {
  PriorityUnspecified = 0;

  // ROUTINE: Normal day-to-day traffic.
  // May be delayed or colescated into a later update when bandwidth is constrained
  PriorityRoutine = 1;

  // IMMEDIATE: Delay would negatively affect the mission
  // Sent before lower precedence messages
  PriorityImmediate = 2;

  // FLASH: Extreme urgency
  // Sent before lower precedence messages and without respecting mission bandwidth/signal limits
  // Highly visible flare, misuse can jeopardize missions
  PriorityFlash = 3;
}

message GeoSpatialComponent {
  double longitude = 1;
  double latitude = 2;

  // height above ellipsoid (WGS84) in meters
  optional double altitude = 3;

  optional CovarianceMatrix covariance = 4;
}

message SymbolComponent {
  string milStd2525C = 1;
}

message InteractivityComponent {
  // use lucide names for max compat
  optional string icon = 1;

  // some url where a user can learn more about this entity
  optional string reference_url = 3;
}

enum CameraProtocol {
  CameraProtocolUnspecified = 0;
  CameraProtocolWebrtc = 1;
  CameraProtocolHls = 2;
  CameraProtocolMjpeg = 3;
  CameraProtocolImage = 4;
  CameraProtocolIframe = 5;
  CameraProtocolRtsp = 6;
}

message Camera {
  string label = 1;
  string url = 2;
  CameraProtocol protocol = 3;

  // horizontal field of view in degrees
  optional double fov = 4;

  // minimum detection range in meters (blind zone)
  optional double range_min = 5;

  // maximum detection range in meters
  optional double range_max = 6;
}

message CameraComponent {
  repeated Camera cameras = 1;
}

message DetectionComponent {
  optional string detectorEntityId = 1;
  optional string classification = 2;
  optional google.protobuf.Timestamp lastMeasured = 3;
}

message BearingComponent {
  optional double azimuth = 1;
  optional double elevation = 2;
}

message SensorComponent {
  // entity IDS of GeoShapeComponent entities that describe the coverage
  repeated string coverage = 2;
}

message Quaternion {
  double x = 1;
  double y = 2;
  double z = 3;
  double w = 4;
}

message CovarianceMatrix {
  optional double mxx = 1;
  optional double mxy = 2;
  optional double mxz = 3;
  optional double myy = 4;
  optional double myz = 5;
  optional double mzz = 6;
}

message OrientationComponent {
  optional Quaternion orientation = 1;
  optional CovarianceMatrix covariance = 2;

  // angular velocity in radians per second (body frame)
  optional double roll_rate = 3;
  optional double pitch_rate = 4;
  optional double yaw_rate = 5;
}

message TrackComponent {
  optional string tracker = 1;

  // entity ID of a GeoShapeComponent containing the track history
  optional string history = 2;

  // entity ID of a GeoShapeComponent containing the predicted forward track
  optional string prediction = 3;
}

message LocatorComponent {
  string locatedEntityId = 1;
}

message TaskableContext {
  optional string entityId = 1;
}

message TaskableAssignee {
  optional string entityId = 1;
}

message TaskableComponent {
  optional string reserved = 1;
  optional string label = 2;
  repeated TaskableContext context = 3;
  repeated TaskableAssignee assignee = 4;
  google.protobuf.Struct schema = 5;
}

message KinematicsEnu {
  // Velocity components in the local East-North-Up (ENU) coordinate frame.
  // The ENU frame is a right-handed Cartesian coordinate system with origin
  // at the entity's position (GeoSpatialComponent), where:
  // - East axis: tangent to the latitude line, pointing eastward
  // - North axis: tangent to the longitude line, pointing northward
  // - Up axis: perpendicular to the WGS84 ellipsoid, pointing away from Earth center
  //
  // Note: This is NOT a body frame - the axes do not rotate with the entity's
  // heading/attitude. Velocities are expressed relative to the Earth's surface.
  // All units are in meters per second (m/s).
  optional double east = 1; // m/s
  optional double north = 2; // m/s
  optional double up = 3; // m/s
  optional CovarianceMatrix covariance = 4;
}

message KinematicsComponent {
  // Velocity in local ENU frame (see KinematicsEnu for frame definition)
  optional KinematicsEnu velocityEnu = 1;
  // Acceleration in local ENU frame (m/sÂ²)
  optional KinematicsEnu accelerationEnu = 2;
}

message Geometry {
  bytes wkb = 1 [deprecated = true];
  PlanarGeometry planar = 2;
}

message GeoShapeComponent {
  optional Geometry geometry = 1;
}

message LocalShapeComponent {
  // entity ID whose frame this geometry is defined in
  string relative_to = 2;

  optional LocalGeometry geometry = 1;
}

enum ClassificationIdentity {
  ClassificationIdentityInvalid = 0;
  ClassificationIdentityPending = 1; // P
  ClassificationIdentityUnknown = 2; // U
  ClassificationIdentityFriend = 3; // F
  ClassificationIdentityNeutral = 4; // N
  ClassificationIdentityHostile = 5; // H
  ClassificationIdentitySuspect = 6; // S
}

enum ClassificationBattleDimension {
  ClassificationBattleDimensionInvalid = 0;
  ClassificationBattleDimensionUnknown = 1; // Z
  ClassificationBattleDimensionSpace = 2; // P
  ClassificationBattleDimensionAir = 3; // A
  ClassificationBattleDimensionGround = 4; // G
  ClassificationBattleDimensionSeaSurface = 5; // S
  ClassificationBattleDimensionSubsurface = 6; // U
}

message ClassificationComponent {
  optional ClassificationBattleDimension dimension = 1;
  optional ClassificationIdentity identity = 2;
}

message TransponderAIS {
  optional uint32 mmsi = 1;
  optional uint32 imo = 2;
  optional string callsign = 3;
  optional string vessel_name = 4;
}

message TransponderADSB {
  optional uint32 icao_address = 1;
  optional string flight_id = 2;
}

message TransponderComponent {
  optional TransponderAIS ais = 1;
  optional TransponderADSB adsb = 2;
}

message AdministrativeComponent {
  optional string id = 1;
  optional string flag = 2;
  optional string owner = 3;
  optional string manufacturer = 4;
  optional string model = 5;
  optional uint32 year_built = 6;
  optional float length_m = 7;
  optional float tonnage_gt = 8;
  optional float engine_power_kw = 9;
}

enum NavigationMode {
  NavigationModeUnspecified = 0;
  NavigationModePlanned = 1; // planned but not yet active
  NavigationModeStationary = 2; // anchored, moored, landed
  NavigationModeUnderway = 3; // might be human-controlled or we dont know
  NavigationModeAutonomous = 4; // executing a known mission / auto
  NavigationModeGuided = 5; // externally guided waypoint by a known system
  NavigationModeLoitering = 6; // orbiting/holding pattern around a point
  NavigationModeReturning = 7; // RTL / RTB
}

// Live navigation telemetry of an asset
message NavigationComponent {
  optional NavigationMode mode = 1;

  optional bool armed = 2;
  optional bool emergency = 3;

  // current waypoint index in the active mission
  optional uint32 waypoint_current = 4;

  // total number of waypoints in the active mission
  optional uint32 waypoint_total = 5;
}

message MissionComponent {
  // asset entity IDs participating in this mission
  repeated string members = 1;

  // human-readable status from the source system. can be multi line / markdown
  optional string description = 2;

  // human-readable destination (e.g. port name)
  optional string destination = 3;

  // estimated time of arrival
  optional google.protobuf.Timestamp eta = 4;
}

enum LinkStatus {
  LinkStatusUnspecified = 0;
  LinkStatusConnected = 1;
  LinkStatusDegraded = 2;
  LinkStatusLost = 3;
}

message LinkComponent {
  optional LinkStatus status = 1;

  // received signal strength indicator in dBm
  optional sint32 rssi_dbm = 2;

  // signal-to-noise ratio in dB
  optional sint32 snr_db = 3;

  // entity id of the device that manages the link to this entity
  optional string via = 5;

  // last measured end-to-end latency in milliseconds
  optional uint32 last_latency_ms = 6;

  // exponential moving average of latency in milliseconds
  optional uint32 avg_latency_ms = 7;

  // last time data was received over this link
  optional google.protobuf.Timestamp last_seen = 8;
}

message CaptureComponent {
  // last raw payload received from this entity
  optional bytes payload = 1;

  // application-level port (e.g. LoRaWAN FPort, UDP port)
  optional uint32 port = 2;

  // content type hint (e.g. "application/octet-stream", "application/json")
  optional string content_type = 3;

  // entity ID of the device that captured this data
  optional string captured_by = 4;

  // when the payload was captured
  optional google.protobuf.Timestamp captured_at = 5;
}

message PowerComponent {
  // battery charge remaining (0.0 - 1.0)
  optional float battery_charge_remaining = 1;

  // battery or board voltage in volts
  optional float voltage = 2;

  // estimated remaining operating time in seconds
  optional uint32 remaining_seconds = 3;
}

enum DeviceState {
  DeviceStatePending = 0;
  DeviceStateActive = 1;
  DeviceStateFailed = 2;
}

enum ConfigurableState {
  ConfigurableStateInactive = 0;
  ConfigurableStateStarting = 1;
  ConfigurableStateActive = 2;
  ConfigurableStateFailed = 3;
  ConfigurableStateConflict = 4;
  ConfigurableStateScheduled = 5;
}

message DeviceClassOption {
  string class = 1;

  // Human-readable label for the UI select (e.g. "USB Serial Device")
  string label = 2;
}

// Presence of this component indicates a controller is managing this entity.
// It declares what can be configured and reports the controller's state.
// Always on the same entity as a DeviceComponent.
// ConfigurationComponent (user-created config) is also placed on this entity.
message ConfigurableComponent {
  google.protobuf.Struct schema = 1;

  // current state reported by the controller
  google.protobuf.Struct value = 2;

  ConfigurableState state = 3;
  optional string error = 4;

  // Human-readable label for the UI (e.g. "Defaults", "USB Device", "Channel 0")
  optional string label = 5;

  // Echoed from ConfigurationComponent.version after the controller
  // has finished processing the configuration.
  uint64 applied_version = 6;

  // what kinds of devices can be attached underneath this entity
  repeated DeviceClassOption supported_device_classes = 7;

  // indicated when the controller will activate this entity
  optional google.protobuf.Timestamp scheduled_at = 8;
}

// Physical device in the device tree. Describes hardware topology only.
// Can be discovered automatically or created by hand.
message DeviceComponent {
  // parent device entity, forming the device tree. unset for root (node).
  optional string parent = 1;

  // TODO might not be needed?
  // list of non-direct ancestors this device is made of
  repeated string composition = 2;

  // a stable identifier that remains the same no matter where the asset is connected to
  // e.g. USB serial number, MAC address. lets the system recognize the same
  // physical hardware even if it moves to a different port or node.
  optional string unique_hardware_id = 4;

  DeviceState state = 6;
  optional string error = 7;

  // device class (e.g. "usb_serial", "radio", "camera")
  optional string class = 10;

  // human-readable category for UI grouping (e.g. "Air", "Sea", "Network")
  optional string category = 13;

  // subsystem-specific descriptors
  optional NodeDevice node = 20;
  optional UsbDevice usb = 21;
  optional IpDevice ip = 22;
  optional SerialDevice serial = 23;
  optional EthernetDevice ethernet = 24;
  optional LPWANDevice lpwan = 25;
}

message NodeDevice {
  optional string hostname = 1;
  optional string os = 2;
  optional string arch = 3;
  optional uint32 num_cpu = 4;
}

message UsbDevice {
  optional uint32 vendor_id = 1;
  optional uint32 product_id = 2;
  optional uint32 device_class = 3;
  optional uint32 device_subclass = 4;
  optional uint32 device_protocol = 5;
  optional string manufacturer_name = 6;
  optional string product_name = 7;
  optional string serial_number = 8;
}

message IpDevice {
  optional string host = 1;
  optional uint32 port = 2;
}

message EthernetDevice {
  // MAC address in canonical colon-separated hex (e.g. "aa:bb:cc:dd:ee:ff")
  optional string mac_address = 1;

  // vendor name resolved from the OUI prefix, if known
  optional string vendor = 2;
}

message SerialDevice {
  optional string path = 1;
  optional uint32 baud_rate = 2;
}

message LPWANDevice {
  // IEEE 802 EUI-64 identifier (e.g. "a84041c6545d1429")
  optional string eui = 1;

  // network address assigned after join/activation (e.g. "012a7125")
  optional string address = 2;
}

// Configuration pushed onto an entity. The engine delivers entities with
// Config to the matching controller via Reconcile.
message ConfigurationComponent {
  google.protobuf.Struct value = 3;

  // Monotonically increasing counter set by the config pusher.
  // The controller echoes this back in ConfigurableComponent.applied_version
  // once the configuration has been processed.
  uint64 version = 5;
}

// ---------------------------------------------

message EntityFilter {
  optional string id = 1; // exact match on entity id
  optional string label = 2; // exact match on entity label
  optional GeoFilter geo = 3; // entity geo intersects with geometry/bounds
  optional TaskableFilter taskable = 4;
  repeated uint32 component = 5; // entity must have ALL these components
  optional ControllerFilter controller = 7;
  optional TrackFilter track = 8;
  optional MissionFilter mission = 9;

  optional DeviceFilter device = 50;
  optional ConfigurationFilter config = 51;

  repeated EntityFilter or = 100; // matches if ANY child filter matches
  EntityFilter not = 101; // matches if child filter does NOT match
}

message ControllerFilter {
  optional string id = 1;
}

message TrackFilter {
  optional string tracker = 1;
}

message MissionFilter {
  // find member assets of this mission
  optional string mission_id = 1;

  // find missions containing this asset
  optional string member_id = 2;
}

message TaskableFilter {
  optional TaskableContext context = 1;
  optional TaskableAssignee assignee = 2;
}

message GeoFilter {
  oneof geo {
    Geometry geometry = 1; // intersects with this geometry (bounding box check)
    string geoEntityId = 2; // intersects with another entity's geo bounds
  }
}

message DeviceFilter {
  // match devices with this parent entity ID (for building the device tree)
  optional string parent = 1;

  optional string unique_hardware_id = 4;
}

message ConfigurationFilter {}

message WatchBehavior {
  // Maximum non-flash message rate this consumer can handle (0 = unlimited)
  optional float max_rate_hz = 1;

  // Only deliver messages at or above this priority level
  // Default (unset or PriorityReserved0) = deliver all priorities
  optional Priority min_priority = 3;

  // Re-stream all matching entities at this interval in milliseconds, even if unchanged.
  // For consumers that dont understand lifetimes and require fixed interval updates
  // 0 or unset = only stream actual changes
  // values lower than 1000 might be capped to 1s
  optional uint32 keepalive_interval_ms = 4;
}

message ListEntitiesRequest {
  reserved 1; //deprecated
  EntityFilter filter = 2;

  optional WatchBehavior behaviour = 4;
}

message ListEntitiesResponse {
  repeated Entity entities = 1;
}

message EntityChangeRequest {
  // components present (set) in the pushed entity are replaced entirely, not recursively.
  // Components not included in the message are left unchanged.
  // missing Components are NOT removed
  repeated Entity changes = 1;

  // replaces the whole entity atoomically.
  // missing Components ARE removed
  repeated Entity replacements = 2;
}

message ExpireEntityRequest {
  string id = 1;
}

message ExpireEntityResponse {}

message EntityChangeResponse {
  bool accepted = 1;
  string debug = 2;
}

enum EntityChange {
  EntityChangeInvalid = 0;
  EntityChangeUpdated = 1;
  EntityChangeExpired = 2;
  EntityChangeUnobserved = 3;
}

message EntityChangeEvent {
  Entity entity = 1;
  EntityChange t = 2;
}

message EntityChangeBatch {
  repeated EntityChangeEvent events = 1;
}

message GetEntityRequest {
  string id = 1;
}

message GetEntityResponse {
  Entity entity = 1;
}

message GetLocalNodeRequest {}

message GetLocalNodeResponse {
  Entity entity = 1;
  string node_id = 2;
}

message ObserverRequest {}

message ObserverState {
  Geometry geo = 1;
  optional google.protobuf.Timestamp viewHistory = 2;
}

message RunTaskRequest {
  string entityId = 1;
}

enum TaskStatus {
  TaskStatusInvalid = 0;
  TaskStatusRunning = 1;
  TaskStatusCompleted = 2;
  TaskStatusFailed = 3;
}

message RunTaskResponse {
  string executionId = 1;
  TaskStatus status = 2;
  optional string humanReadableReason = 3;
}

// interact with the world model
service WorldService {
  // list entities present in the world once
  rpc ListEntities(ListEntitiesRequest) returns (ListEntitiesResponse);

  // request every detail about one entity
  rpc GetEntity(GetEntityRequest) returns (GetEntityResponse);

  // continously monitor entities present in the world. this is used by downstream C2.
  rpc WatchEntities(ListEntitiesRequest) returns (stream EntityChangeEvent);

  // Create or update an entity. Used by capabilities.
  rpc Push(EntityChangeRequest) returns (EntityChangeResponse);

  // expire an entity, setting its lifetime.until to now
  rpc ExpireEntity(ExpireEntityRequest) returns (ExpireEntityResponse);

  // get information about the local node the client is connected to
  rpc GetLocalNode(GetLocalNodeRequest) returns (GetLocalNodeResponse);

  // create an instance of a specific task entity
  rpc RunTask(RunTaskRequest) returns (RunTaskResponse);
}
