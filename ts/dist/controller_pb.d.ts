// @generated by protoc-gen-es v2.10.2 with parameter "target=js+dts,import_extension=none"
// @generated from file controller.proto (package world, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { Entity } from "./world_pb";

/**
 * Describes the file controller.proto.
 */
export declare const file_controller: GenFile;

/**
 * @generated from message world.ControllerReconciliationRequest
 */
export declare type ControllerReconciliationRequest = Message<"world.ControllerReconciliationRequest"> & {
  /**
   * @generated from field: string controller = 1;
   */
  controller: string;
};

/**
 * Describes the message world.ControllerReconciliationRequest.
 * Use `create(ControllerReconciliationRequestSchema)` to create a new message.
 */
export declare const ControllerReconciliationRequestSchema: GenMessage<ControllerReconciliationRequest>;

/**
 * a (config, device) match was added, changed, or removed
 *
 * @generated from message world.ControllerDeviceConfigurationEvent
 */
export declare type ControllerDeviceConfigurationEvent = Message<"world.ControllerDeviceConfigurationEvent"> & {
  /**
   * @generated from field: world.ControllerDeviceConfigurationEventType t = 1;
   */
  t: ControllerDeviceConfigurationEventType;

  /**
   * @generated from field: world.Entity config = 2;
   */
  config?: Entity;

  /**
   * @generated from field: world.Entity device = 3;
   */
  device?: Entity;
};

/**
 * Describes the message world.ControllerDeviceConfigurationEvent.
 * Use `create(ControllerDeviceConfigurationEventSchema)` to create a new message.
 */
export declare const ControllerDeviceConfigurationEventSchema: GenMessage<ControllerDeviceConfigurationEvent>;

/**
 * @generated from message world.ControllerReconciliationEvent
 */
export declare type ControllerReconciliationEvent = Message<"world.ControllerReconciliationEvent"> & {
  /**
   * @generated from oneof world.ControllerReconciliationEvent.event
   */
  event: {
    /**
     * @generated from field: world.ControllerDeviceConfigurationEvent config = 2;
     */
    value: ControllerDeviceConfigurationEvent;
    case: "config";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message world.ControllerReconciliationEvent.
 * Use `create(ControllerReconciliationEventSchema)` to create a new message.
 */
export declare const ControllerReconciliationEventSchema: GenMessage<ControllerReconciliationEvent>;

/**
 * @generated from enum world.ControllerDeviceConfigurationEventType
 */
export enum ControllerDeviceConfigurationEventType {
  /**
   * @generated from enum value: ControllerDeviceConfigurationEventNew = 0;
   */
  ControllerDeviceConfigurationEventNew = 0,

  /**
   * @generated from enum value: ControllerDeviceConfigurationEventChanged = 1;
   */
  ControllerDeviceConfigurationEventChanged = 1,

  /**
   * @generated from enum value: ControllerDeviceConfigurationEventRemoved = 2;
   */
  ControllerDeviceConfigurationEventRemoved = 2,
}

/**
 * Describes the enum world.ControllerDeviceConfigurationEventType.
 */
export declare const ControllerDeviceConfigurationEventTypeSchema: GenEnum<ControllerDeviceConfigurationEventType>;

/**
 * API for controllers to receive work from the engine.
 *
 * The engine matches ConfigurationComponent entities to DeviceComponent entities
 * using the config's selector, and streams the results as
 * ControllerDeviceConfigurationEvent messages carrying both the config and device entity.
 *
 * ## Engine guarantees
 *
 *   - Every New event is eventually followed by a Removed event
 *     for that (config.id, device.id) pair.
 *   - Each event carries the full config and device entities.
 *
 * ## Event sequences by scenario
 *
 *   Stream starts:
 *     New(config, device) for each existing match
 *
 *   Config added, no devices match yet:
 *     (no events until a device matches)
 *
 *   Config added, devices already match:
 *     New(config, device) for each match
 *
 *   Config value updated (selector unchanged):
 *     Changed(config, device) for all matched devices
 *       (carries new config entity)
 *
 *   Config selector changed:
 *     Removed(config, device) for devices that no longer match
 *     New(config, device) for newly matching devices
 *     Changed(config, device) for devices that still match
 *
 *   Config removed:
 *     Removed(config, device) for all matched devices
 *
 *   Device appears, matches existing config(s):
 *     New(config, device) per matching config
 *
 *   Device updated, still matches:
 *     Changed(config, device) with updated device entity
 *
 *   Device updated, match set changes:
 *     Removed(config, device) from configs it no longer matches
 *     New(config, device) to configs it now newly matches
 *
 *   Device removed:
 *     Removed(config, device) for each config it was matched to
 *
 * ## 1:1 mode — one connector per (config, device) pair
 *
 *   New     → start connector (carries full config + device)
 *   Changed → restart connector, or pass update to running connector
 *   Removed → stop connector
 *
 * ## 1:N mode — one connector per config, devices added/removed dynamically
 *
 *   New     → add device to connector, start connector if first device for this config
 *   Changed → update device or config in connector
 *   Removed → remove device from connector, stop connector if last device removed
 *
 *
 * @generated from service world.ControllerService
 */
export declare const ControllerService: GenService<{
  /**
   * @generated from rpc world.ControllerService.Reconcile
   */
  reconcile: {
    methodKind: "server_streaming";
    input: typeof ControllerReconciliationRequestSchema;
    output: typeof ControllerReconciliationEventSchema;
  },
}>;

